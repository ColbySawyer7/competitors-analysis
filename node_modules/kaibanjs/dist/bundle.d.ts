import { Tool } from 'langchain/tools';

/**
 * ### Agent status
 * @enum {string}
 * @readonly
 * @property {string} INITIAL - The agent is set up and waiting to start the task.
 * @property {string} THINKING - The agent is strategizing and planning the approach based on the initial input.
 * @property {string} THOUGHT - The agent has formed a plan and is ready to act. This involves deciding on specific actions based on the reasoning.
 * @property {string} EXECUTING_ACTION - The agent is actively performing the actions determined in the thought phase.
 * @property {string} USING_TOOL - The agent is interacting with external tools to gather or verify information necessary for completing the task.
 * @property {string} OBSERVATION - The agent analyzes the results from the tools to update its understanding and plan.
 * @property {string} FINAL_ANSWER - The agent concludes the task with a final decision based on all collected and processed information.
 * @property {string} IDLE - The agent is idle, waiting for new instructions or tasks.
 */
declare enum AGENT_STATUS_enum {
  INITIAL = 'INITIAL',
  THINKING = 'THINKING',
  THINKING_END = 'THINKING_END',
  THINKING_ERROR = 'THINKING_ERROR',
  THOUGHT = 'THOUGHT',
  EXECUTING_ACTION = 'EXECUTING_ACTION',
  USING_TOOL = 'USING_TOOL',
  USING_TOOL_END = 'USING_TOOL_END',
  USING_TOOL_ERROR = 'USING_TOOL_ERROR',
  TOOL_DOES_NOT_EXIST = 'TOOL_DOES_NOT_EXIST',
  OBSERVATION = 'OBSERVATION',
  FINAL_ANSWER = 'FINAL_ANSWER',
  TASK_COMPLETED = 'TASK_COMPLETED',
  MAX_ITERATIONS_ERROR = 'MAX_ITERATIONS_ERROR',
  ISSUES_PARSING_LLM_OUTPUT = 'ISSUES_PARSING_LLM_OUTPUT',
  SELF_QUESTION = 'SELF_QUESTION',
  ITERATION_START = 'ITERATION_START',
  ITERATION_END = 'ITERATION_END',
  AGENTIC_LOOP_ERROR = 'AGENTIC_LOOP_ERROR',
  WEIRD_LLM_OUTPUT = 'WEIRD_LLM_OUTPUT',
}

/**
 * ### Task status
 * @enum {string}
 * @readonly
 * @property {string} TODO - Task is queued for initiation, awaiting processing.
 * @property {string} DOING - Task is actively being worked on.
 * @property {string} BLOCKED - Progress on the task is halted due to dependencies or obstacles.
 * @property {string} REVISE - Task requires additional review or adjustments.
 * @property {string} DONE - Task is completed and requires no further action.
 */
declare enum TASK_STATUS_enum {
  TODO = 'TODO',
  DOING = 'DOING',
  BLOCKED = 'BLOCKED',
  REVISE = 'REVISE',
  DONE = 'DONE',
}

/**
 * ### Store types
 * @typedef {any} TStore
 * @todo Implement various stores later on.
 */
type TStore = any;

/**
 * ### Agent types
 * @typedef {"ReactChampionAgent"} TAgentTypes
 */
type TAgentTypes = 'ReactChampionAgent';

/**
 * ### BaseAgent params
 * @interface IBaseAgentParams
 * @property {string} name - The name of the agent.
 * @property {string} role - The role of the agent.
 * @property {string} goal - The goal of the agent.
 * @property {string} background - The background of the agent.
 * @property {Tool[]} [tools] - The tools available to the agent.
 * @property {ILLMConfig} [llmConfig] - The language model configuration.
 * @property {number} [maxIterations] - The maximum number of iterations.
 * @property {boolean} [forceFinalAnswer] - Whether to force the final answer.
 */
interface IBaseAgentParams {
  name: string;
  role: string;
  goal: string;
  background: string;
  tools?: Tool[];
  llmConfig?: ILLMConfig;
  maxIterations?: number;
  forceFinalAnswer?: boolean;
  llmInstance?: any;
}

/**
 * ### BaseAgent
 * Used to reference the core BaseAgent class type.
 * @class
 * @property {string} id - The agent's unique identifier.
 * @property {TStore} store - The store used by the agent.
 * @property {AGENT_STATUS_enum} status - The agent's current status.
 * @property {Record<string, any> | null} env - The agent's environment variables.
 * @property {string} llmSystemMessage - The agent's system message.
 * @property {string} name - The agent's name.
 * @property {string} role - The agent's role.
 * @property {string} goal - The agent's goal.
 * @property {string} background - The agent's background.
 * @property {Tool[]} tools - The tools available to the agent.
 * @property {ILLMConfig} llmConfig - The language model configuration.
 * @property {number} maxIterations - The maximum number of iterations.
 * @property {boolean} forceFinalAnswer - Whether to force the final answer.
 */
declare class BaseAgent {
  id: string;
  store: TStore;
  status: AGENT_STATUS_enum;
  env: Record<string, any> | null;
  llmSystemMessage: string;

  name: string;
  role: string;
  goal: string;
  background: string;
  tools: Tool[];
  llmConfig: ILLMConfig;
  maxIterations: number;
  forceFinalAnswer: boolean;
  llmInstance: any;

  /**
   * Creates an instance of BaseAgent.
   * @param {IBaseAgentParams} params - The agent's parameters.
   */
  constructor(params: IBaseAgentParams);

  /**
   * Sets the store.
   * @param {TStore} store - The store to be set.
   */
  setStore(store: TStore): void;

  /**
   * Sets the status of the agent.
   * @param {AGENT_STATUS_enum} status - The status to be set.
   */
  setStatus(status: AGENT_STATUS_enum): void;

  /**
   * Sets the environment variables.
   * @param {Record<string, any>} env - The environment variables to be set.
   */
  setEnv(env: Record<string, any>): void;
}

/**
 * ### Various api keys
 * @interface IApiKeys
 * @property {string} [openai] - The OpenAI API key.
 * @property {string} [google] - The Google API key.
 * @property {string} [anthropic] - The Anthropic API key.
 * @property {string} [mistral] - The Mistral API key.
 */
interface IApiKeys {
  openai?: string;
  google?: string;
  anthropic?: string;
  mistral?: string;
}

/**
 * ### LLM configuration
 * @interface ILLMConfig
 * @property {("openai" | "google" | "anthropic" | "mistral")} provider - The provider of the language model.
 * @property {string} model - The model to be used.
 * @property {number} maxRetries - The maximum number of retries.
 * @property {IApiKeys} [apiKey] - The API key for the provider.
 */
interface ILLMConfig {
  provider: 'openai' | 'google' | 'anthropic' | 'mistral';
  model: string;
  maxRetries: number;
  apiKey?: IApiKeys;
}

/**
 * ### LLM usage stats
 * @interface ILLMUsageStats
 * @property {number} inputTokens - The number of input tokens.
 * @property {number} outputTokens - The number of output tokens.
 * @property {number} callsCount - The number of calls.
 * @property {number} callsErrorCount - The number of calls with errors.
 * @property {number} parsingErrors - The number of parsing errors.
 */
interface ILLMUsageStats {
  inputTokens: number;
  outputTokens: number;
  callsCount: number;
  callsErrorCount: number;
  parsingErrors: number;
}

/**
 * ### Task stats
 * @interface ITaskStats
 * @property {number} startTime - The start time of the task.
 * @property {number} endTime - The end time of the task.
 * @property {number} duration - The duration of the task.
 * @property {ILLMUsageStats} llmUsageStats - The LLM usage statistics.
 * @property {number} iterationCount - The iteration count.
 */
interface ITaskStats {
  startTime: number;
  endTime: number;
  duration: number;
  llmUsageStats: ILLMUsageStats;
  iterationCount: number;
}

// Type definitions for "kaibanjs" 0.1.0
// Project: kaibanjs
// Author: @darielnoel <github.com/darielnoel>
// Definitions by: @alienkarma <github.com/alienkarma>



/**
 * ### Agent parameters
 * @interface IAgentParams
 * @extends IBaseAgentParams
 * @property {TAgentTypes} type - The type of agent.
 */
interface IAgentParams extends IBaseAgentParams {
  type?: TAgentTypes;
}

/**
 * ### Agent
 * A class representing an agent.
 * @class
 * @extends BaseAgent
 * @property {BaseAgent} agentInstance - The agent instance.
 * @property {string} type - The type of agent.
 */
declare class Agent {
  agentInstance: BaseAgent;
  type: string;

  /**
   * Creates an instance of an Agent.
   * @param {IAgentParams} config - The configuration parameters for the agent.
   */
  constructor(config: IAgentParams);

  /**
   * Creates an agent.
   * @param {TAgentTypes} type - The type of agent.
   * @param {IBaseAgentParams} config - The configuration parameters for the agent.
   * @returns {BaseAgent} The created agent instance.
   */
  createAgent(type: TAgentTypes, config: IBaseAgentParams): BaseAgent;

  /**
   * Executes a task.
   * @param {Task} task - The task to be executed.
   * @returns {Promise<string>} A promise resolving with the task result.
   */
  executeTask(task: Task): Promise<string>;

  /**
   * Sets the store.
   * @param {TStore} store - The store to be set.
   */
  setStore(store: TStore): void;

  /**
   * Sets the environment variables.
   * @param {Record<string, any>} env - The environment variables to be set.
   */
  setEnv(env: Record<string, any>): void;

  /**
   * Sets the status of the agent.
   * @param {AGENT_STATUS_enum} status - The status to be set.
   */
  setStatus(status: AGENT_STATUS_enum): void;

  /**
   * Returns the agent ID.
   * @returns {string} The agent ID.
   */
  id(): string;

  /**
   * Returns the agent name.
   * @returns {string} The agent name.
   */
  name(): string;

  /**
   * Returns the agent role.
   * @returns {string} The agent role.
   */
  role(): string;

  /**
   * Returns the agent goal.
   * @returns {string} The agent goal.
   */
  goal(): string;

  /**
   * Returns the agent background.
   * @returns {string} The agent background.
   */
  background(): string;

  /**
   * Returns the tools available to the agent.
   * @returns {Tool[]} The list of tools.
   */
  tools(): Tool[];

  /**
   * Returns the status of the agent.
   * @returns {AGENT_STATUS_enum} The agent's status.
   */
  status(): AGENT_STATUS_enum;

  /**
   * Returns the configuration for the language model.
   * @returns {ILLMConfig} The language model configuration.
   */
  llmConfig(): ILLMConfig;

  /**
   * Returns the system message for the language model.
   * @returns {string} The language model system message.
   */
  llmSystemMessage(): string;

  /**
   * Indicates whether the agent is forced to provide a final answer.
   * @returns {boolean} True if the agent is forced to give a final answer, otherwise false.
   */
  forceFinalAnswer(): boolean;
}

/**
 * ### Task parameters
 * @interface ITaskParams
 * @property {string} [title] - The title of the task.
 * @property {string} description - The description of the task.
 * @property {string} expectedOutput - The expected output of the task.
 * @property {BaseAgent} agent - The agent to execute the task.
 * @property {boolean} [isDeliverable] - Indicates whether the task is deliverable.
 */
interface ITaskParams {
  title?: string;
  description: string;
  expectedOutput: string;
  agent: Agent;
  isDeliverable?: boolean;
}

/**
 * ### Task
 * A class representing a task.
 * @class
 * @property {string} id - The task ID.
 * @property {string} title - The task title.
 * @property {string} description - The task description.
 * @property {string} expectedOutput - The expected output of the task.
 * @property {boolean} isDeliverable - Indicates whether the task is deliverable.
 * @property {Agent} agent - The agent to execute the task.
 * @property {TASK_STATUS_enum} status - The status of the task.
 * @property {string} result - The result of the task.
 * @property {ITaskStats | null} stats - The statistics of the task.
 * @property {number | null} duration - The duration of the task.
 * @property {Task[]} dependencies - The dependencies of the task.
 * @property {string | null} interpolatedTaskDescription - The interpolated task description.
 * @property {TStore} store - The store.
 */
declare class Task {
  id: string;
  title: string;
  description: string;
  expectedOutput: string;
  isDeliverable: boolean;
  agent: Agent;
  status: TASK_STATUS_enum;
  result: string;
  stats: ITaskStats | null;
  duration: number | null;
  dependencies: Task[];
  interpolatedTaskDescription: string | null;
  store: TStore;

  /**
   * Creates an instance of a Task.
   * @param {ITaskParams} params - The parameters for the task.
   */
  constructor(params: ITaskParams);

  /**
   * Executes the task.
   * @param {TStore} store - The store.
   */
  setStore(store: TStore): void;
}

/**
 * ### Team parameters
 * @interface ITeamParams
 * @property {string} name - The name of the team.
 * @property {BaseAgent[]} [agents] - The agents in the team.
 * @property {Task[]} [tasks] - The tasks for the team.
 * @property {string} [logLevel] - The log level for the team.
 * @property {Record<string, string>} [inputs] - The inputs for the team.
 * @property {Record<string, any> | null} [env] - The environment variables for the team.
 */
interface ITeamParams {
  name: string;
  agents?: Agent[];
  tasks?: Task[];
  logLevel?: string;
  inputs?: Record<string, any>;
  env?: Record<string, any> | null;
}

/**
 * ### Team
 * A class representing a team.
 * @class
 * @property {TStore} store - The store instance.
 */
declare class Team {
  store: TStore;

  /**
   * Creates an instance of a Team.
   * @param {ITeamParams} params - The parameters for the team.
   */
  constructor(params: ITeamParams);

  /**
   * Starts the team operations.
   * @returns {Promise<void>} A promise resolving when the team has started.
   */
  start(): Promise<void>;

  /**
   * Returns the store.
   * @returns {TStore} The store instance.
   */
  getStore(): TStore;

  /**
   * Returns the store instance in use.
   * @returns {TStore} The store instance.
   */
  useStore(): TStore;

  /**
   * Subscribes to changes in the team.
   * @param {(newValues: any) => void} listener - The listener function that will be called on changes.
   * @param {string[]} [properties] - The specific properties to listen to.
   * @returns {() => void} A function to unsubscribe from the changes.
   */
  subscribeToChanges(
    listener: (newValues: any) => void,
    properties?: string[]
  ): () => void;
}

export { Agent, type IAgentParams, type ITaskParams, type ITeamParams, Task, Team };
