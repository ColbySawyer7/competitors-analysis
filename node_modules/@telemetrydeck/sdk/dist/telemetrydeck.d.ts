export { TelemetryDeck as default };
export type TelemetryDeckOptions = {
    /**
     * the app ID to send telemetry data to
     */
    appID: string;
    /**
     * the clientUser ID to send telemetry data to
     */
    clientUser: string;
    /**
     * the target URL to send telemetry data to
     */
    target?: string;
    /**
     * An optional session ID to include in each signal
     */
    sessionID?: string;
    /**
     * A salt to use when hashing the clientUser ID
     */
    salt?: string;
    /**
     * If "true", signals will be marked as test signals and only show up in Test Mode in the Dashbaord
     */
    testMode?: boolean;
    /**
     * A store to use for queueing signals
     */
    store?: Store;
    /**
     * Used for providing an alternative implementation of SubtleCrypto where no browser is available. Expects a class providing a `.digest(method, value)` method.
     */
    subtleCrypto?: Function;
};
export type TelemetryDeckPayload = {
    [x: string]: any;
};
/**
 * @typedef {Object} TelemetryDeckOptions
 *
 * @property {string} appID the app ID to send telemetry data to
 * @property {string} clientUser the clientUser ID to send telemetry data to
 * @property {string} [target] the target URL to send telemetry data to
 * @property {string} [sessionID] An optional session ID to include in each signal
 * @property {string} [salt] A salt to use when hashing the clientUser ID
 * @property {boolean} [testMode] If "true", signals will be marked as test signals and only show up in Test Mode in the Dashbaord
 * @property {Store} [store] A store to use for queueing signals
 * @property {Function} [subtleCrypto] Used for providing an alternative implementation of SubtleCrypto where no browser is available. Expects a class providing a `.digest(method, value)` method.
 */
/**
 * @typedef {Object.<string, any>} TelemetryDeckPayload
 */
declare class TelemetryDeck {
    /**
     *
     * @param {TelemetryDeckOptions} options
     */
    constructor(options?: TelemetryDeckOptions);
    appID: string;
    clientUser: string;
    salt: string;
    target: string;
    testMode: boolean;
    store: Store;
    sessionID: string;
    subtleCrypto: Function;
    /**
     * Send a TelemetryDeck signal
     *
     * @param {string} type the type of telemetry data to send
     * @param {TelemetryDeckPayload} [payload] custom payload to be stored with each signal
     * @param {TelemetryDeckOptions} [options]
     * @returns <Promise<Response>> a promise with the response from the server, echoing the sent data
     */
    signal(type: string, payload?: TelemetryDeckPayload, options?: TelemetryDeckOptions): Promise<Response>;
    /**
     * Enqueue a signal to be sent to TelemetryDeck later.
     *
     * Use flush() to send all queued signals.
     *
     * @param {string} type
     * @param {TelemetryDeckPayload} [payload]
     * @param {TelemetryDeckOptions} [options]
     * @returns <Promise>
     */
    queue(type: string, payload?: TelemetryDeckPayload, options?: TelemetryDeckOptions): Promise<void>;
    /**
     * Send all queued signals to TelemetryDeck.
     *
     * Enqueue signals with queue().
     *
     * @returns <Promise<Response>> a promise with the response from the server, echoing the sent data
     */
    flush(): Promise<Response>;
    _clientUserAndSalt: string;
    _clientUserHashed: string;
    _hashedClientUser(clientUser: any, salt: any): Promise<string>;
    _build(type: any, payload: any, options: any, receivedAt: any): Promise<any>;
    _appendPayload(body: any, payload: any): any;
    _post(body: any): Promise<Response>;
}
declare class Store {
    push(value: any): Promise<void>;
    clear(): void;
    values(): any[];
    #private;
}
